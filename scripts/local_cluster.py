#!/usr/bin/env python3
"""
Utility script to bootstrap a multi-node PnyxDB cluster on the local workstation.

The script automates the manual steps described in README.md:
  * build the `pnyxdb` binary
  * create per-node working directories with tailored config files
  * generate password-protected keyrings
  * exchange and endorse public keys so every node trusts the others

Example:
    PASSWORD=secret python3 scripts/local_cluster.py \
        --nodes alice bob carol dave \
        --workspace ./clusters/local-demo

After the script finishes you can start a node with:
    ./bin/pnyxdb -c clusters/local-demo/alice/config.yaml server
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
from pathlib import Path
from textwrap import dedent


def build_binary(bin_path: Path):
    if bin_path.exists():
        return
    bin_path.parent.mkdir(parents=True, exist_ok=True)
    print(f"[build] go build -o {bin_path} .")
    run(["go", "build", "-o", str(bin_path), "."], cwd=Path(__file__).resolve().parents[1])


def write_config(
    path: Path,
    node: str,
    n_nodes: int,
    p2p_port: int,
    api_port: int,
    listen_host: str = "127.0.0.1",
    api_host: str = "127.0.0.1",
):
    f = (n_nodes - 1) // 3
    w = 1 + (n_nodes + f) // 2
    config = dedent(
        f"""
        # Autogenerated by scripts/local_cluster.py
        identity: {node}
        keyring: {node}.pem
        n: {n_nodes}
        w: {w}

        db:
          path: {node}.db
          driver: boltdb

        p2p:
          listen: "/ip4/{listen_host}/tcp/{p2p_port}"
          peers: []

        recoveryQuorum: {w}

        api:
          listen: "{api_host}:{api_port}"
        """
    ).strip()
    path.write_text(config + "\n", encoding="utf-8")




def bootstrap(nodes, workspace, password, base_p2p, base_api):
    repo_root = Path(__file__).resolve().parents[1]
    workspace = workspace.resolve()
    workspace.mkdir(parents=True, exist_ok=True)

    bin_path = repo_root / "bin" / "pnyxdb"
    build_binary(bin_path)

    configs = {}
    for idx, node in enumerate(nodes):
        node_dir = workspace / node
        node_dir.mkdir(parents=True, exist_ok=True)
        cfg_path = node_dir / "config.yaml"
        write_config(cfg_path, node, len(nodes), base_p2p + idx, base_api + idx)
        env = {"PASSWORD": password}
        subprocess.run([str(bin_path), "-c", str(cfg_path), "keys", "init"], env=env, check=True)
        configs[node] = cfg_path

    # Export keys once
    key_material = {}
    for node, cfg in configs.items():
        result = subprocess.run([str(bin_path), "-c", str(cfg), "keys", "export"], check=True, capture_output=True, text=True)
        key_material[node] = result.stdout

    # Cross import and sign
    for node, cfg in configs.items():
        for peer, exported in key_material.items():
            if peer == node:
                continue
            subprocess.run(
                [str(bin_path), "-c", str(cfg), "keys", "import", peer, "--trust", "high"],
                input=exported,
                text=True,
                check=True,
            )
            subprocess.run(
                [str(bin_path), "-c", str(cfg), "keys", "sign", peer],
                env={"PASSWORD": password},
                check=True,
            )

    print("\nCluster initialized SUCCESSFULLY.\n")
    for node, cfg in configs.items():
        print(f"  {node}: {cfg}")
    print(
        "\nStart a node with:\n"
        "  PASSWORD=**** ./bin/pnyxdb -c <node-dir>/config.yaml server\n"
        "Grab the multiaddr printed by the first node and add it to other configs under p2p.peers."
    )


def parse_args():
    parser = argparse.ArgumentParser(description="Bootstrap a local multi-node PnyxDB cluster.")
    parser.add_argument("--nodes", nargs="+", default=["alice", "bob", "carol", "dave"], help="Node identities to create.")
    parser.add_argument("--workspace", type=Path, default=Path("clusters/local"), help="Directory to store generated configs.")
    parser.add_argument("--password", default=os.environ.get("PASSWORD"), help="Encryption password for every keyring.")
    parser.add_argument("--base-p2p", type=int, default=4100, help="First TCP port for P2P listeners.")
    parser.add_argument("--base-api", type=int, default=4200, help="First TCP port for API listeners.")
    return parser.parse_args()


def main():
    args = parse_args()
    if not args.password:
        print("ERROR: provide --password or set PASSWORD env var.", file=sys.stderr)
        sys.exit(1)

    nodes = []
    for name in args.nodes:
        sanitized = name.strip()
        if not sanitized:
            continue
        nodes.append(sanitized)
    if len(nodes) < 1:
        print("ERROR: at least one node required.", file=sys.stderr)
        sys.exit(1)

    bootstrap(nodes, args.workspace, args.password, args.base_p2p, args.base_api)


if __name__ == "__main__":
    main()
