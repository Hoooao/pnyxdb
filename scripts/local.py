#!/usr/bin/env python3
"""Bootstrap and run a local PnyxDB cluster."""

from __future__ import annotations

import argparse
import os
import shutil
import subprocess
import sys
import threading
import time
from dataclasses import dataclass
from pathlib import Path
from typing import List, TextIO

from datetime import datetime


API_BASE_PORT = 4200


def current_timestamp() -> str:
    now = datetime.now().astimezone()
    return f"{now.strftime('%Y-%m-%dT%H:%M:%S')}.{now.microsecond // 1000:03d}{now.strftime('%z')}"


def reset_directory(path: Path) -> None:
    if path.exists():
        print(f"Removing existing directory: {path}")
        shutil.rmtree(path)


@dataclass
class ReplicaHandle:
    name: str
    process: subprocess.Popen
    log_file: TextIO
    log_path: Path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run a local PnyxDB cluster.")
    parser.add_argument("-r", "--replicas", type=int, default=4, help="Number of replicas to start.")
    parser.add_argument("-p", "--password", default='1', help="Password passed to setup_cluster and replicas.")
    parser.add_argument("-b", "--binary", type=Path, default=Path("./pnyxdb"), help="Path to the pnyxdb binary.")
    parser.add_argument("--machines-dir", type=Path, default=Path("machines"), help="Directory where replica folders live.")
    parser.add_argument("--logs-dir", type=Path, default=Path("logs"), help="Directory where replica logs are stored.")
    parser.add_argument("--api-ip", default="127.0.0.1", help="IP passed to setup_cluster for API listeners.")
    parser.add_argument("--client-replica", type=int, default=0, help="Replica id used for the autogenerated client workload.")
    parser.add_argument("--client-rate", type=float, default=1.0, help="Client ADD operations per second (0 = as fast as possible).")
    parser.add_argument("--client-duration", type=float, default=0.0, help="Duration in seconds to issue ADD operations after initial SET.")
    parser.add_argument("--client-start-delay", type=float, default=2.0, help="Seconds to wait before issuing client commands.")
    parser.add_argument(
        "--skip-setup",
        action="store_true",
        help="Skip running setup_cluster (assumes replica dirs already initialized).",
    )
    return parser.parse_args()


def run_setup_cluster(args: argparse.Namespace, binary: Path, machines_dir: Path) -> None:
    script_dir = Path(__file__).resolve().parent
    setup_script = script_dir / "setup_cluster.py"
    if not setup_script.is_file():
        raise FileNotFoundError(f"setup_cluster.py not found at {setup_script}")

    machines_dir.mkdir(parents=True, exist_ok=True)
    cmd: List[str] = [
        sys.executable,
        str(setup_script),
        "--replicas",
        str(args.replicas),
        "--password",
        args.password,
        "--binary",
        str(binary),
        "--api-ip",
        args.api_ip,
    ]
    local_config = script_dir / "local_config.yaml"
    if not local_config.is_file():
        raise FileNotFoundError(f"local_config.yaml not found at {local_config}")
    cmd.extend(["--ip-config", str(local_config)])
    print("Running setup_cluster...")
    subprocess.run(cmd, check=True, cwd=machines_dir)


def launch_replicas(args: argparse.Namespace, binary: Path, machines_dir: Path, logs_dir: Path, env: dict[str, str]) -> list[ReplicaHandle]:
    handles: list[ReplicaHandle] = []
    logs_dir.mkdir(parents=True, exist_ok=True)
    for idx in range(args.replicas):
        replica_name = f"replica{idx}"
        replica_dir = machines_dir / replica_name
        cfg_path = replica_dir / "config.yaml"
        if not cfg_path.is_file():
            raise FileNotFoundError(f"Missing config for {replica_name}: {cfg_path}")

        log_path = logs_dir / f"{replica_name}.log"
        log_file = log_path.open("w", encoding="utf-8")
        cmd = [str(binary), "-c", str(cfg_path), "server", "start"]
        print(f"Starting {replica_name}: {' '.join(cmd)}")
        try:
            process = subprocess.Popen(
                cmd,
                cwd=replica_dir,
                stdout=log_file,
                stderr=subprocess.STDOUT,
                env=env,
            )
        except Exception:
            log_file.close()
            raise
        handles.append(ReplicaHandle(name=replica_name, process=process, log_file=log_file, log_path=log_path))
    return handles


def wait_for_replicas(handles: list[ReplicaHandle], stop_event: threading.Event) -> None:
    finished: set[str] = set()
    try:
        while True:
            active = 0
            for handle in handles:
                ret = handle.process.poll()
                if ret is None:
                    active += 1
                elif handle.name not in finished:
                    finished.add(handle.name)
                    print(f"{handle.name} exited with code {ret}")
            if active == 0:
                break
            time.sleep(1)
    except KeyboardInterrupt:
        print("Interrupt received, stopping replicas...")
        stop_event.set()


def cleanup(handles: list[ReplicaHandle]) -> None:
    for handle in handles:
        if handle.process.poll() is None:
            handle.process.terminate()
    for handle in handles:
        if handle.process.poll() is None:
            try:
                handle.process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                handle.process.kill()
                handle.process.wait()
    for handle in handles:
        handle.log_file.close()
        print(f"Logs available at {handle.log_path}")


def run_client_workload(
    args: argparse.Namespace,
    binary: Path,
    env: dict[str, str],
    stop_event: threading.Event,
    logs_dir: Path,
) -> None:
    if args.client_rate < 0:
        raise SystemExit("client-rate must be >= 0")
    if args.client_duration < 0:
        raise SystemExit("client-duration must be >= 0")
    if args.client_replica < 0 or args.client_replica >= args.replicas:
        raise SystemExit("client-replica must target an existing replica id")

    api_port = API_BASE_PORT + args.client_replica
    server_addr = f"{args.api_ip}:{api_port}"
    client_base_cmd = [str(binary), "client", "-s", server_addr]
    log_path = logs_dir / f"client{args.client_replica}.log"
    logs_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_path.open("a", encoding="utf-8")

    def log_message(message: str) -> None:
        log_file.write(f"[{current_timestamp()}] {message}\n")
        log_file.flush()

    def run_command(extra_args: list[str]) -> None:
        cmd = client_base_cmd + extra_args
        msg = f"Client command: {' '.join(cmd)}"
        print(msg)
        subprocess.run(cmd, check=True, env=env, stdout=log_file, stderr=subprocess.STDOUT)
        log_file.flush()

    try:
        time.sleep(max(0.0, args.client_start_delay))
        if stop_event.is_set():
            return

        try:
            run_command(["SET", "counter", "1"])
        except Exception as exc:  # pragma: no cover - user feedback
            err = f"Client SET failed: {exc}"
            print(err)
            log_message(err)
            return

        if args.client_duration == 0:
            return

        interval = 0.0 if args.client_rate <= 0 else 1.0 / args.client_rate
        end_time = time.time() + args.client_duration
        while time.time() < end_time and not stop_event.is_set():
            try:
                run_command(["ADD", "counter", "1"])
            except Exception as exc:  # pragma: no cover - user feedback
                err = f"Client ADD failed: {exc}"
                print(err)
                log_message(err)
                break
            if interval == 0.0:
                continue
            stop_event.wait(interval)
    finally:
        log_message("Client workload finished")
        log_file.close()


def main() -> None:
    args = parse_args()
    if args.replicas <= 0:
        raise SystemExit("replicas must be > 0")

    binary = Path(args.binary).expanduser().resolve()
    if not binary.is_file():
        raise FileNotFoundError(f"Binary not found: {binary}")

    machines_dir = Path(args.machines_dir).expanduser().resolve()
    logs_dir = Path(args.logs_dir).expanduser().resolve()

    reset_directory(logs_dir)
    if not args.skip_setup:
        reset_directory(machines_dir)
        run_setup_cluster(args, binary, machines_dir)

    env = os.environ.copy()
    env["PASSWORD"] = args.password

    handles = launch_replicas(args, binary, machines_dir, logs_dir, env)
    stop_event = threading.Event()
    client_thread = threading.Thread(
        target=run_client_workload,
        args=(args, binary, env, stop_event, logs_dir),
        name="client-workload",
        daemon=True,
    )
    client_thread.start()
    try:
        wait_for_replicas(handles, stop_event)
    finally:
        stop_event.set()
        cleanup(handles)
        client_thread.join(timeout=5)


if __name__ == "__main__":
    main()
