#!/usr/bin/env python3
"""
Automate the README steps:
 1. create replica directories (replica0..replicaN)
 2. run `pnyxdb init` inside each dir (auto-fill prompts with node name)
 3. run `pnyxdb keys init`
 4. export each public key
 5. import every other key with trust=high

Usage:
    python3 scripts/setup_cluster.py --replicas 4 --password secret --binary ./pnyxdb
"""

from __future__ import annotations

import argparse
import os
import subprocess
import tempfile
from pathlib import Path
from textwrap import dedent


def run(cmd, *, cwd=None, input_text=None, env=None):
    subprocess.run(
        cmd,
        cwd=cwd,
        input=input_text,
        text=True,
        env=env,
        check=True,
    )


def run_capture(cmd, cwd=None, env=None):
    result = subprocess.run(cmd, cwd=cwd, text=True, env=env, check=True, capture_output=True)
    return result.stdout


def write_config(path: Path, node: str, total: int, p2p_port: int, api_port: int, peers: list[str]):
    f = (total - 1) // 3
    w = 1 + (total + f) // 2
    peers_block = "\n".join(f"    - \"{peer}\"" for peer in peers) or "    - \"\""
    config = dedent(
        f"""
# Autogenerated by scripts/setup_cluster.py
identity: {node}
keyring: {node}.pem
n: {total}
w: {w}

db:
    path: {node}.db
    driver: boltdb

p2p:
    listen: "/ip4/127.0.0.1/tcp/{p2p_port}"
    peers:
{peers_block}

recoveryQuorum: {w}

api:
    listen: "127.0.0.1:{api_port}"
        """
    ).strip()
    path.write_text(config + "\n", encoding="utf-8")


def extract_peer_id(binary: Path, cfg: Path) -> str:
    env = os.environ.copy()
    env["PASSWORD"] = env.get("PASSWORD", "")
    result = subprocess.run(
        [str(binary), "-c", str(cfg), "server", "--print-peer-id"],
        cwd=cfg.parent,
        text=True,
        capture_output=True,
        check=True,
        env=env,
    )
    return result.stdout.strip()


def setup_replicas(count: int, password: str, binary: Path):
    binary = binary.resolve()
    if not binary.is_file():
        raise FileNotFoundError(f"Binary not found: {binary}")

    temp_dir = tempfile.TemporaryDirectory()
    temp_path = Path(temp_dir.name)

    nodes = []
    for idx in range(count):
        name = f"replica{idx}"
        p2p_port = 4100 + idx
        api_port = 4200 + idx
        node_dir = Path(name).resolve()
        node_dir.mkdir(parents=True, exist_ok=True)

        cfg = node_dir / "config.yaml"
        nodes.append(
            {
                "name": name,
                "cfg": cfg,
                "p2p": p2p_port,
                "api": api_port,
                "dir": node_dir,
            }
        )
        write_config(cfg, name, count, p2p_port, api_port, [])

    for node in nodes:
        cfg = node["cfg"]
        node_dir = node["dir"]
        env = os.environ.copy()
        env["PASSWORD"] = password
        run([str(binary), "-c", str(cfg), "keys", "init"], cwd=node_dir, env=env)

        pub_path = temp_path / f"{node['name']}"
        with pub_path.open("w", encoding="utf-8") as fh:
            subprocess.run(
                [str(binary), "-c", str(cfg), "keys", "export"],
                cwd=node_dir,
                text=True,
                check=True,
                stdout=fh,
            )
        node["peerID"] = extract_peer_id(binary, cfg)

    # Update configs with full peer multiaddrs
    for node in nodes:
        peers = [
            f"/ip4/127.0.0.1/tcp/{peer['p2p']}/p2p/{peer['peerID']}"
            for peer in nodes
            if peer["name"] != node["name"]
        ]
        write_config(node["cfg"], node["name"], count, node["p2p"], node["api"], peers)

    # 4) import peers
    for idx, node in enumerate(nodes):
        cfg = node["cfg"]
        for peer_idx, peer in enumerate(nodes):
            if idx == peer_idx:
                continue
            peer_name = peer["name"]
            pub_path = temp_path / f"{peer_name}"
            if not pub_path.exists():
                raise FileNotFoundError(f"Missing exported key for {peer_name}: {pub_path}")
            with pub_path.open("r", encoding="utf-8") as stream:
                subprocess.run(
                    [str(binary), "-c", str(cfg), "keys", "import", peer_name, "--trust", "high"],
                    text=True,
                    stdin=stream,
                    check=True,
                    cwd=cfg.parent,
                )

    temp_dir.cleanup()
    print(f"Initialized {count} replicas under {Path.cwd()}")


def parse_args():
    parser = argparse.ArgumentParser(description="Bootstrap local PnyxDB replicas.")
    parser.add_argument("-r", "--replicas", type=int, required=True, help="Number of replica directories to create.")
    parser.add_argument("-p", "--password", required=True, help="Password for all keyrings.")
    parser.add_argument("-b", "--binary", type=Path, default=Path("./pnyxdb"), help="Path to the pnyxdb binary.")
    return parser.parse_args()


def main():
    args = parse_args()
    if args.replicas <= 0:
        raise SystemExit("replicas must be > 0")
    setup_replicas(args.replicas, args.password, args.binary)


if __name__ == "__main__":
    main()
